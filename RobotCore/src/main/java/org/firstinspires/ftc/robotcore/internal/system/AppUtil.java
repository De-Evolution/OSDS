/*
Copyright (c) 2016 Robert Atkinson

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted (subject to the limitations in the disclaimer below) provided that
the following conditions are met:

Redistributions of source code must retain the above copyright notice, this list
of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

Neither the name of Robert Atkinson nor the names of his contributors may be used to
endorse or promote products derived from this software without specific prior
written permission.

NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS
LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESSFOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package org.firstinspires.ftc.robotcore.internal.system;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.AlertDialog;
import android.app.Application;
import android.app.PendingIntent;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Configuration;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.support.annotation.ColorInt;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.text.InputType;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

import com.qualcomm.robotcore.R;
import com.qualcomm.robotcore.robocol.Command;
import com.qualcomm.robotcore.util.RobotLog;

import org.firstinspires.ftc.robotcore.external.Consumer;
import org.firstinspires.ftc.robotcore.external.Predicate;
import org.firstinspires.ftc.robotcore.internal.collections.MutableReference;
import org.firstinspires.ftc.robotcore.internal.files.MediaTransferProtocolMonitor;
import org.firstinspires.ftc.robotcore.internal.network.NetworkConnectionHandler;
import org.firstinspires.ftc.robotcore.internal.network.RobotCoreCommandList;
import org.firstinspires.ftc.robotcore.internal.ui.ProgressParameters;
import org.firstinspires.ftc.robotcore.internal.ui.UILocation;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Random;
import java.util.TimeZone;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CountDownLatch;

/**
 * {@link AppUtil} contains a few utilities related to application and activity management.
 */
@SuppressWarnings({"WeakerAccess", "JavaDoc"})
public class AppUtil {
    //----------------------------------------------------------------------------------------------
    // Directory management
    // See also OnBotJavaManager.
    //----------------------------------------------------------------------------------------------

    /**
     * The root of all external storage that we use
     */
    public static final File ROOT_FOLDER = Environment.getExternalStorageDirectory();

    /**
     * Where to place logs
     */
    public static final File LOG_FOLDER = ROOT_FOLDER;

    /**
     * {@link #FIRST_FOLDER} is the root of the tree we use in non-volatile storage. Robot configurations
     * are stored in this folder.
     */
    public static final File FIRST_FOLDER = new File(ROOT_FOLDER + "/FIRST/");

    /**
     * Dirctory in which .xml robot configurations should live
     */
    public static final File CONFIG_FILES_DIR = FIRST_FOLDER;

    /**
     * Opmodes generated by the blocks programming tool are stored in {@link #BLOCK_OPMODES_DIR}
     */
    public static final File BLOCK_OPMODES_DIR = new File(FIRST_FOLDER, "/blocks/");
    public static final String BLOCKS_BLK_EXT = ".blk";
    public static final String BLOCKS_JS_EXT = ".js";

    /**
     * {@link #ROBOT_SETTINGS} is a folder in which it's convenient to store team-generated settings
     * associated with their robot
     */
    public static final File ROBOT_SETTINGS = new File(FIRST_FOLDER, "/settings/");

    /**
     * {@link #ROBOT_DATA_DIR} is a convenient place in which to put persistent data created by your opmode
     */
    public static final File ROBOT_DATA_DIR = new File(FIRST_FOLDER, "/data/");

    /**
     * {@link #UPDATES_DIR} is a folder used to manage updates to firmware, installed APKs, and other components
     */
    public static final File UPDATES_DIR = new File(FIRST_FOLDER, "/updates/");
    public static final File RC_APP_UPDATE_DIR = new File(UPDATES_DIR, "/Robot Controller Application/");
    public static final File LYNX_FIRMWARE_UPDATE_DIR = new File(UPDATES_DIR, "/Expansion Hub Firmware/");

    //----------------------------------------------------------------------------------------------
    // Static State
    //----------------------------------------------------------------------------------------------

    public static final String TAG = "AppUtil";

    private static class InstanceHolder {
        public static AppUtil theInstance = new AppUtil();
    }

    public static AppUtil getInstance() {
        return InstanceHolder.theInstance;
    }

    public static Context getDefContext() {
        return getInstance().getApplication();
    }

    //----------------------------------------------------------------------------------------------
    // State
    //----------------------------------------------------------------------------------------------

    private
    @NonNull
    Application application;
    private LifeCycleMonitor lifeCycleMonitor;
    private Activity rootActivity;
    private Activity currentActivity;
    private ProgressDialog currentProgressDialog;
    private Random random;

    //----------------------------------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------------------------------

    public static void onApplicationStart(@NonNull Application application) {
        getInstance().initialize(application);
    }

    protected AppUtil() {
    }

    protected void initialize(@NonNull Application application) {
        lifeCycleMonitor = new LifeCycleMonitor();
        rootActivity = null;
        currentActivity = null;
        currentProgressDialog = null;
        random = new Random();

        application.registerActivityLifecycleCallbacks(lifeCycleMonitor);

        // REVIEW: Why do this AFTER registering?
        this.application = application;

        RobotLog.vv(TAG, "initializing: getExternalStorageDirectory()=%s", Environment.getExternalStorageDirectory());
    }

    //----------------------------------------------------------------------------------------------
    // File and Directory Management
    //----------------------------------------------------------------------------------------------

    /**
     * Given a root File and a child underneath same returns the path from the former to the latter
     */
    public File getRelativePath(File root, File child) {
        File result = new File("");
        while (!root.equals(child)) {
            File parent = child.getParentFile();
            result = new File(new File(child.getName()), result.getPath());
            if (parent == null) {
                break;
            }
            child = parent;
        }
        return result;
    }

    /**
     * Make sure all the components of the path exist, notifying MTP if necessary for any creations
     */
    public void ensureDirectoryExists(final File directory) {
        ensureDirectoryExists(directory, true);
    }

    public void ensureDirectoryExists(final File directory, boolean notify) {
        if (!directory.isDirectory()) {
            directory.delete(); // might be a file; get rid of same

            File parent = directory.getParentFile();
            if (parent != null) {
                ensureDirectoryExists(parent, notify);
            }

            if (directory.mkdir()) {
                // Successfully newly created the dir. Notify MTP. However, MTP doesn't like to be
                // notified of directories. So we make a temp file, notify on that, then delete same
                // once the scan has completed.
                if (notify) {
                    MediaTransferProtocolMonitor.makeIndicatorFile(directory);
                }
            } else {
                // already existed, or error; latter logged & ignored. Try to clean up any indicator files.
                if (directory.isDirectory()) {
                    // all is well
                } else {
                    RobotLog.ee(TAG, "failed to create directory %s", directory);
                }
                if (notify) {
                    MediaTransferProtocolMonitor.renoticeIndicatorFiles(directory);
                }
            }
        }
    }

    public void deleteChildren(File file) {
        File[] children = file.listFiles();
        if (children != null) {
            for (File child : children) {
                delete(child);
            }
        }
    }

    /**
     * Delete the indicated file or directory, clearing directories as needed
     */
    public void delete(File file) {
        deleteChildren(file);
        if (!file.delete()) {
            RobotLog.ee(TAG, "failed to delete '%s'", file.getAbsolutePath());
        }
    }

    public List<File> filesUnder(File directory) {
        return filesUnder(directory, (Predicate<File>) null);
    }

    /**
     * Return all the files (ie: not directories) under root for which predicate returns true
     */
    public List<File> filesUnder(File parent, @Nullable Predicate<File> predicate) {
        ArrayList<File> result = new ArrayList<>();
        if (parent.isDirectory()) {
            for (File child : parent.listFiles()) {
                result.addAll(filesUnder(child, predicate));
            }
        } else if (parent.exists()) {
            if (predicate == null || predicate.test(parent)) {
                result.add(parent.getAbsoluteFile());
            }
        }
        return result;
    }

    public List<File> filesUnder(File parent, @NonNull final String extension) {
        return filesUnder(parent, new Predicate<File>() {
            @Override
            public boolean test(File file) {
                return file.getName().endsWith(extension);
            }
        });
    }

    public List<File> filesIn(File directory) {
        return filesIn(directory, (Predicate<File>) null);
    }

    public List<File> filesIn(File directory, @Nullable Predicate<File> predicate) {
        ArrayList<File> result = new ArrayList<>();
        File[] children = directory.listFiles();
        if (children != null) {
            for (File child : children) {
                if (predicate == null || predicate.test(child)) {
                    result.add(child.getAbsoluteFile());
                }
            }
        }
        return result;
    }

    public List<File> filesIn(File directory, @NonNull final String extension) {
        return filesIn(directory, new Predicate<File>() {
            @Override
            public boolean test(File file) {
                return file.getName().endsWith(extension);
            }
        });
    }

    public File getSettingsFile(String filename) {
        File file = new File(filename);
        if (!file.isAbsolute()) {
            ensureDirectoryExists(ROBOT_SETTINGS);
            file = new File(ROBOT_SETTINGS, filename);
        }
        return file;
    }

    public void copyFile(File fromFile, File toFile) throws IOException {
        InputStream inputStream = new FileInputStream(fromFile);
        try {
            copyStream(inputStream, toFile);
        } finally {
            inputStream.close();
        }
    }

    public void copyStream(InputStream inputStream, File toFile) throws IOException {
        OutputStream outputStream = new FileOutputStream(toFile);
        try {
            copyStream(inputStream, outputStream);
        } finally {
            outputStream.close();
        }
    }

    public void copyStream(File inputFile, OutputStream outputStream) throws IOException {
        InputStream inputStream = new FileInputStream(inputFile);
        try {
            copyStream(inputStream, outputStream);
        } finally {
            inputStream.close();
        }
    }

    public void copyStream(InputStream inputStream, OutputStream outputStream) throws IOException {
        int cbBuffer = Math.min(4096, inputStream.available());
        byte[] buffer = new byte[cbBuffer];
        for (; ; ) {
            int cbRead = inputStream.read(buffer);
            if (cbRead <= 0) {
                break;
            }
            outputStream.write(buffer, 0, cbRead);
        }
    }

    public File createTempFile(@NonNull String prefix, @Nullable String suffix, @Nullable File directory) throws IOException {
        return File.createTempFile(prefix, suffix, directory);
    }

    public File createTempDirectory(@NonNull String prefix, @Nullable String suffix, @Nullable File directory) throws IOException {
        /** @see File#createTempFile */
        if (prefix.length() < 3) {
            throw new IllegalArgumentException("prefix must be at least 3 characters");
        }
        if (suffix == null) {
            suffix = ".tmp";
        }
        File tmpDirFile = directory;
        if (tmpDirFile == null) {
            String tmpDir = System.getProperty("java.io.tmpdir", ".");
            tmpDirFile = new File(tmpDir);
        }
        File result;
        do {
            result = new File(tmpDirFile, prefix + random.nextInt() + suffix);
        }
        while (!result.mkdir()); // mkdir returns false failure or if the directory already existed.
        return result;
    }

    //----------------------------------------------------------------------------------------------
    // Life Cycle
    //----------------------------------------------------------------------------------------------

    /**
     * Restarts the current application
     *
     * @param exitCode the exit code to return from the current app run
     */
    public void restartApp(int exitCode) {
        // See http://stackoverflow.com/questions/2681499/android-how-to-auto-restart-application-after-its-been-force-closed
        RobotLog.vv(TAG, "restarting app");

        @SuppressWarnings("WrongConstant") PendingIntent pendingIntent = PendingIntent.getActivity(
                getApplication().getBaseContext(),
                0,
                new Intent(rootActivity.getIntent()),
                rootActivity.getIntent().getFlags());

        // Carry out the restart by having the AlarmManager (re)issue our intent after a delay
        // that's long enough for us to get out of the way in the first place.
        int msRestartDelay = 1500;
        AlarmManager alarmManager = (AlarmManager) rootActivity.getSystemService(Context.ALARM_SERVICE);
        alarmManager.set(AlarmManager.RTC, System.currentTimeMillis() + msRestartDelay, pendingIntent);
        System.exit(exitCode);
    }

    public void finishRootActivityAndExitApp() {
        synchronousRunOnUiThread(new Runnable() {
            @Override
            public void run() {
                RobotLog.vv(TAG, "finishRootActivityAndExitApp()");
                if (Build.VERSION.SDK_INT >= 21) {
                    rootActivity.finishAndRemoveTask();
                } else {
                    rootActivity.finish();
                }
                exitApplication();
            }
        });
    }

    public void exitApplication(int resultCode) {
        RobotLog.vv(TAG, "exitApplication(%d)", resultCode);
        System.exit(resultCode);
    }

    public void exitApplication() {
        exitApplication(0);
    }

    //----------------------------------------------------------------------------------------------
    // Application
    //----------------------------------------------------------------------------------------------

    /**
     * Returns the contextually running {@link Application}
     *
     * @return the contextually running {@link Application}
     */
    public
    @NonNull
    Application getApplication() {
        return this.application;
    }

    /**
     * Returns the application id of this current application, the identifier
     * that distinguishes it from all other applications. This is the 'packageName' in
     * the ultimately-shipped manifest, but that differs from the 'packageName' attribute
     * in the source AndroidManifest.xml.
     *
     * @see <a href="https://developer.android.com/studio/build/application-id.html">Application Id</a>
     */
    public String getApplicationId() {
        return getApplication().getPackageName();
    }

    public boolean isRobotController() {
        return getApplicationId().equals(getDefContext().getString(R.string.packageNameRobotController));
    }

    public boolean isDriverStation() {
        return getApplicationId().equals(getDefContext().getString(R.string.packageNameDriverStation));
    }

    public String getAppName() {
        if (isRobotController()) {
            return getDefContext().getString(R.string.appNameRobotController);
        } else if (isDriverStation()) {
            return getDefContext().getString(R.string.appNameDriverStation);
        } else {
            return getDefContext().getString(R.string.appNameUnknown);
        }
    }

    public String getRemoteAppName() {
        if (isRobotController()) {
            return getDefContext().getString(R.string.appNameDriverStation);
        } else if (isDriverStation()) {
            return getDefContext().getString(R.string.appNameRobotController);
        } else {
            return getDefContext().getString(R.string.appNameUnknown);
        }
    }

    //----------------------------------------------------------------------------------------------
    // UI interaction
    //----------------------------------------------------------------------------------------------

    public
    @ColorInt
    int getColor(int id) {
        if (Build.VERSION.SDK_INT >= 23) {
            return getDefContext().getColor(id);
        } else {
            return getDefContext().getResources().getColor(id);
        }
    }

    /**
     * This works around a deliberate bug Google introduced to prevent options menus from working
     * on large screens. It is a hack, in the classic sense of the word. But it works. Onward...
     *
     * @param activity the guy whose options menu is to be opened
     * @see <a href="http://stackoverflow.com/questions/9996333/openoptionsmenu-function-not-working-in-ics/17903128#17903128">discussion</a>
     */
    public void openOptionsMenuFor(Activity activity) {
        Configuration config = activity.getResources().getConfiguration();
        if ((config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK) > Configuration.SCREENLAYOUT_SIZE_LARGE) {
            int originalScreenLayout = config.screenLayout;
            config.screenLayout = Configuration.SCREENLAYOUT_SIZE_LARGE;
            try {
                activity.openOptionsMenu();
            } finally {
                config.screenLayout = originalScreenLayout;
            }
        } else {
            activity.openOptionsMenu();
        }
    }

    /**
     * A drop-in replacement for {@link Activity#runOnUiThread(Runnable) runonUiThread()} which doesn't
     * return until the UI action is complete.
     *
     * @param action the action to perform on the UI thread
     */
    public void synchronousRunOnUiThread(final Runnable action) {
        synchronousRunOnUiThread(getActivity(), action);
    }

    public void synchronousRunOnUiThread(Activity activity, final Runnable action) {
        try {
            final CountDownLatch uiDone = new CountDownLatch(1);
            activity.runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    action.run();
                    uiDone.countDown();
                }
            });
            uiDone.await();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    /**
     * A simple helper so that callers have syntactically similar forms for both synchronous and non.
     */
    public void runOnUiThread(final Runnable action) {
        runOnUiThread(getActivity(), action);
    }

    public void runOnUiThread(Activity activity, final Runnable action) {
        activity.runOnUiThread(action);
    }

    public void showWaitCursor(@NonNull final String message, @NonNull final Runnable runnable) {
        showWaitCursor(message, runnable, null);
    }

    public void showWaitCursor(@NonNull final String message, @NonNull final Runnable backgroundWorker, @Nullable final Runnable runPostOnUIThread) {
        this.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                new AsyncTask<Object, Void, Void>() {
                    ProgressDialog dialog;

                    @Override
                    protected void onPreExecute() {
                        dialog = new ProgressDialog(getActivity());
                        dialog.setMessage(message);
                        dialog.setIndeterminate(true);
                        dialog.setCancelable(false);
                        dialog.show();
                    }

                    @Override
                    protected Void doInBackground(Object... params) {
                        backgroundWorker.run();
                        return null;
                    }

                    @Override
                    protected void onPostExecute(Void aVoid) {
                        dialog.dismiss();
                        if (runPostOnUIThread != null) {
                            runPostOnUIThread.run();
                        }
                    }
                }.execute();
            }
        });
    }

    //----------------------------------------------------------------------------------------------
    // Progress Dialog remoting
    //----------------------------------------------------------------------------------------------

    public void showProgress(UILocation uiLocation, final String message, final double fractionComplete) {
        showProgress(uiLocation, message, ProgressParameters.fromFraction(fractionComplete));
    }

    public void showProgress(UILocation uiLocation, final String message, final double fractionComplete, int max) {
        showProgress(uiLocation, message, ProgressParameters.fromFraction(fractionComplete, max));
    }

    public void showProgress(UILocation uiLocation, final String message, ProgressParameters progressParameters) {
        showProgress(uiLocation, this.getActivity(), message, progressParameters);
    }

    public void showProgress(UILocation uiLocation, final Activity activity, final String message, final ProgressParameters progressParameters) {
        final int maxMax = 10000;   // per ProgressBar.MAX_LEVEL
        final int cappedMax = Math.min(progressParameters.max, maxMax);

        this.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                if (currentProgressDialog == null) {
                    currentProgressDialog = new ProgressDialog(activity);
                    currentProgressDialog.setMessage(message);
                    currentProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
                    currentProgressDialog.setMax(cappedMax);
                    currentProgressDialog.setProgress(0);
                    currentProgressDialog.setCanceledOnTouchOutside(false);
                    currentProgressDialog.show();
                }
                currentProgressDialog.setProgress(progressParameters.cur);
            }
        });

        if (uiLocation == UILocation.BOTH) {
            RobotCoreCommandList.ShowProgress showProgress = new RobotCoreCommandList.ShowProgress();
            showProgress.message = message;
            showProgress.cur = progressParameters.cur;
            showProgress.max = progressParameters.max;
            NetworkConnectionHandler.getInstance().sendCommand(new Command(RobotCoreCommandList.CMD_SHOW_PROGRESS, showProgress.serialize()));
        }
    }

    public void dismissProgress(UILocation uiLocation) {
        this.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                if (currentProgressDialog != null) {
                    currentProgressDialog.dismiss();
                    currentProgressDialog = null;
                }
            }
        });

        if (uiLocation == UILocation.BOTH) {
            NetworkConnectionHandler.getInstance().sendCommand(new Command(RobotCoreCommandList.CMD_DISMISS_PROGRESS));
        }
    }

    //----------------------------------------------------------------------------------------------
    // Alert / Confirm / Prompt Dialog
    // https://developer.android.com/guide/topics/ui/dialogs.html
    //----------------------------------------------------------------------------------------------

    public enum DialogFlavor {ALERT, CONFIRM, PROMPT}

    private Map<String, DialogContext> dialogContextMap = new ConcurrentHashMap<>();

    public static class DialogContext {
        public enum Outcome {UNKNOWN, CANCELLED, CONFIRMED}

        public final CountDownLatch dismissed = new CountDownLatch(1);

        protected final String uuidString;
        protected AlertDialog dialog;
        protected boolean isArmed = true;
        protected Outcome outcome = Outcome.UNKNOWN;
        protected CharSequence textResult = null;
        protected EditText input = null;

        public DialogContext(String uuidString) {
            this.uuidString = uuidString;
        }

        public Outcome getOutcome() {
            return outcome;
        }

        public CharSequence getText() {
            return textResult;
        }
    }

    public DialogContext showAlertDialog(UILocation uiLocation, String title, String message) {
        return showAlertDialog(uiLocation, getActivity(), title, message);
    }

    public DialogContext showAlertDialog(String uuidString, UILocation uiLocation, String title, String message) // for remoting
    {
        return showDialog(uuidString, uiLocation, DialogFlavor.ALERT, getActivity(), title, message, null, null);
    }

    public synchronized DialogContext showAlertDialog(final UILocation uiLocation, final Activity activity, final String title, final String message) {
        return showDialog(uiLocation, DialogFlavor.ALERT, activity, title, message, null, null);
    }

    public synchronized DialogContext showDialog(
            final UILocation uiLocation, final DialogFlavor flavor, final Activity activity,
            final String title, final String message, @Nullable final String defaultValue,
            @Nullable final Consumer<DialogContext> runOnDismiss) {
        return showDialog(null, uiLocation, flavor, activity, title, message, defaultValue, runOnDismiss);
    }

    private synchronized DialogContext showDialog(@Nullable String uuidString,
                                                  final UILocation uiLocation, final DialogFlavor flavor, final Activity activity,
                                                  final String title, final String message, @Nullable final String defaultValue,
                                                  @Nullable final Consumer<DialogContext> runOnDismiss) {
        final RobotCoreCommandList.ShowDialog showDialog = new RobotCoreCommandList.ShowDialog();
        showDialog.title = title;
        showDialog.message = message;
        showDialog.uuidString = uuidString != null ? uuidString : UUID.randomUUID().toString();

        final MutableReference<DialogContext> result = new MutableReference<>();
        this.synchronousRunOnUiThread(new Runnable() // note the synchronicity
        {
            @Override
            public void run() {
                // Whenever the dialog goes away, for whatever reason, we need to (a) fire the
                // CountDownLatch to unstick whomever might be awaiting, and (b) make sure to dismiss
                // from the other side, too, if appropriate.
                final DialogContext dialogContext = new DialogContext(showDialog.uuidString);

                AlertDialog.Builder builder = new AlertDialog.Builder(activity);
                builder.setTitle(title);
                builder.setMessage(message);
                switch (flavor) {
                    case ALERT:
                        builder.setNeutralButton(R.string.buttonNameOK, new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog, int which) {
                                dialogContext.outcome = DialogContext.Outcome.CONFIRMED;
                            }
                        });
                        break;
                    case PROMPT:
                        // https://stackoverflow.com/questions/10903754/input-text-dialog-android
                        dialogContext.input = new EditText(activity);
                        dialogContext.input.setInputType(InputType.TYPE_CLASS_TEXT);
                        if (defaultValue != null) {
                            dialogContext.input.setText(defaultValue);
                        }
                        builder.setView(dialogContext.input);
                        // fall through
                    case CONFIRM:
                        if (uiLocation != UILocation.ONLY_LOCAL) {
                            throw new IllegalArgumentException("remote confirmation dialogs not yet supported");
                        }
                        builder.setPositiveButton(R.string.buttonNameOK, new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog, int which) {
                                RobotLog.vv(TAG, "dialog OK clicked: uuid=%s", dialogContext.uuidString);
                                dialogContext.outcome = DialogContext.Outcome.CONFIRMED;
                                // Capture the text while we know we're on a good thread
                                if (dialogContext.input != null) {
                                    dialogContext.textResult = dialogContext.input.getText();
                                }
                                dialog.dismiss();
                            }
                        });
                        builder.setNegativeButton(R.string.buttonNameCancel, new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog, int which) {
                                RobotLog.vv(TAG, "dialog cancel clicked: uuid=%s", dialogContext.uuidString);
                                dialog.cancel();
                            }
                        });
                        break;
                }

                dialogContext.dialog = builder.create();
                dialogContext.dialog.setOnShowListener(new DialogInterface.OnShowListener() {
                    @Override
                    public void onShow(DialogInterface dialog) {
                        RobotLog.vv(TAG, "dialog shown: uuid=%s", dialogContext.uuidString);
                    }
                });
                dialogContext.dialog.setOnCancelListener(new DialogInterface.OnCancelListener() {
                    @Override
                    public void onCancel(DialogInterface dialog) {
                        RobotLog.vv(TAG, "dialog cancelled: uuid=%s", dialogContext.uuidString);
                        dialogContext.outcome = DialogContext.Outcome.CANCELLED;
                    }
                });
                dialogContext.dialog.setOnDismissListener(new DialogInterface.OnDismissListener() {
                    @Override
                    public void onDismiss(DialogInterface dialog) {
                        RobotLog.vv(TAG, "dialog dismissed: uuid=%s", dialogContext.uuidString);
                        dialogContext.dismissed.countDown();
                        if (runOnDismiss != null) {
                            runOnUiThread(activity, new Runnable() {
                                @Override
                                public void run() {
                                    runOnDismiss.accept(dialogContext);
                                }
                            });
                        }
                        if (dialogContext.isArmed) {
                            // Actively dismissing on the DS should also dismiss on the RC, and visa versa
                            RobotCoreCommandList.DismissDialog dismissDialog = new RobotCoreCommandList.DismissDialog(showDialog.uuidString);
                            dismissDialog(UILocation.BOTH, dismissDialog);
                        }
                    }
                });

                dialogContextMap.put(dialogContext.uuidString, dialogContext);
                result.value = dialogContext;
                dialogContext.dialog.show();
            }
        });

        Assert.assertNotNull(result.value);

        if (uiLocation == UILocation.BOTH) {
            NetworkConnectionHandler.getInstance().sendCommand(new Command(RobotCoreCommandList.CMD_SHOW_DIALOG, showDialog.serialize()));
        }

        return result.value;
    }

    public void dismissDialog(UILocation uiLocation, RobotCoreCommandList.DismissDialog dismissDialog) {
        dismissDialog(dismissDialog.uuidString);
        if (uiLocation == UILocation.BOTH) {
            NetworkConnectionHandler.getInstance().sendCommand(new Command(RobotCoreCommandList.CMD_DISMISS_DIALOG, dismissDialog.serialize()));
        }
    }

    protected void dismissDialog(final String uuidString) {
        this.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                DialogContext dialogContext = dialogContextMap.remove(uuidString);
                if (dialogContext != null) {
                    dialogContext.isArmed = false;
                    dialogContext.dialog.dismiss();
                }
            }
        });
    }

    public void dismissAllDialogs(UILocation uiLocation) {
        List<String> uuidStrings = new ArrayList<>(dialogContextMap.keySet());
        for (String uuidString : uuidStrings) {
            dismissDialog(uuidString);
        }
        if (uiLocation == UILocation.BOTH) {
            NetworkConnectionHandler.getInstance().sendCommand(new Command(RobotCoreCommandList.CMD_DISMISS_ALL_DIALOGS));
        }
    }

    //----------------------------------------------------------------------------------------------
    // Toast
    //----------------------------------------------------------------------------------------------

    /**
     * Displays a toast message to the user. May be called from any thread.
     */
    public void showToast(UILocation uiLocation, String msg) {
        showToast(uiLocation, getActivity(), getApplication(), msg);
    }

    public void showToast(UILocation uiLocation, String msg, int duration) {
        showToast(uiLocation, getActivity(), getApplication(), msg, duration);
    }

    public void showToast(UILocation uiLocation, Context context, String msg) {
        showToast(uiLocation, getActivity(), context, msg);
    }

    public void showToast(UILocation uiLocation, final Activity activity, Context context, String msg) {
        showToast(uiLocation, activity, context, msg, Toast.LENGTH_SHORT);
    }

    public void showToast(UILocation uiLocation, final Activity activity, final Context context, final String msg, final int duration) {
        activity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Toast toast = Toast.makeText(context, msg, duration);
                TextView message = (TextView) toast.getView().findViewById(android.R.id.message);
                message.setTextColor(getColor(R.color.text_toast));
                message.setTextSize(18);
                toast.show();
            }
        });

        if (uiLocation == UILocation.BOTH) {
            RobotCoreCommandList.ShowToast showToast = new RobotCoreCommandList.ShowToast();
            showToast.message = msg;
            showToast.duration = duration;
            NetworkConnectionHandler.getInstance().sendCommand(new Command(RobotCoreCommandList.CMD_SHOW_TOAST, showToast.serialize()));
        }
    }

    //----------------------------------------------------------------------------------------------
    // Activities
    //----------------------------------------------------------------------------------------------

    /**
     * Returns the contextually running {@link Activity}
     *
     * @return the contextually running {@link Activity}
     */
    public Activity getActivity() {
        return currentActivity;
    }

    /**
     * Returns the root activity of the current application
     *
     * @return the root activity of the current application
     */
    public Activity getRootActivity() {
        return rootActivity;
    }

    private void initializeRootActivityIfNecessary() {
        // Modified for Turbo: If we detect that this is a splash screen activity, don't set it as root.
        if (rootActivity == null && !currentActivity.getClass().getName().toLowerCase().contains("splash")) {
            rootActivity = currentActivity;
            RobotLog.vv(TAG, "rootActivity=%s", rootActivity.getClass().getSimpleName());
        }
    }

    /**
     * {@link LifeCycleMonitor} is a class that allows us to keep track of the currently active Activity.
     */
    private class LifeCycleMonitor implements Application.ActivityLifecycleCallbacks {
        @Override
        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
            currentActivity = activity;
            initializeRootActivityIfNecessary();
        }

        @Override
        public void onActivityStarted(Activity activity) {
            currentActivity = activity;
            initializeRootActivityIfNecessary();
        }

        @Override
        public void onActivityResumed(Activity activity) {
            currentActivity = activity;
            initializeRootActivityIfNecessary();
        }

        @Override
        public void onActivityPaused(Activity activity) {
        }

        @Override
        public void onActivityStopped(Activity activity) {
        }

        @Override
        public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
        }

        @Override
        public void onActivityDestroyed(Activity activity) {
            if (activity == rootActivity && rootActivity != null) {
                RobotLog.vv(TAG, "rootActivity=%s destroyed", rootActivity.getClass().getSimpleName());
                rootActivity = null;
            }
        }
    }

    //----------------------------------------------------------------------------------------------
    // Date and time
    //----------------------------------------------------------------------------------------------

    public SimpleDateFormat getIso8601DateFormat() {
        // From https://en.wikipedia.org/wiki/ISO_8601
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.US);
        formatter.setTimeZone(TimeZone.getTimeZone("UTC"));
        return formatter;
    }

    //----------------------------------------------------------------------------------------------
    // System
    //----------------------------------------------------------------------------------------------

    public RuntimeException unreachable() {
        return unreachable(TAG);
    }

    public RuntimeException unreachable(Throwable throwable) {
        return unreachable(TAG, throwable);
    }

    public RuntimeException unreachable(String tag) {
        return failFast(tag, "internal error: this code is unreachable");
    }

    public RuntimeException unreachable(String tag, Throwable throwable) {
        return failFast(tag, throwable, "internal error: this code is unreachable");
    }

    public RuntimeException failFast(String tag, String format, Object... args) {
        String message = String.format(format, args);
        return failFast(tag, message);
    }

    public RuntimeException failFast(String tag, String message) {
        RobotLog.ee(tag, message);
        exitApplication(-1);
        return new RuntimeException("keep compiler happy");
    }

    public RuntimeException failFast(String tag, Throwable throwable, String format, Object... args) {
        String message = String.format(format, args);
        return failFast(tag, throwable, message);
    }

    public RuntimeException failFast(String tag, Throwable throwable, String message) {
        RobotLog.ee(tag, throwable, message);
        exitApplication(-1);
        return new RuntimeException("keep compiler happy", throwable);
    }

}
